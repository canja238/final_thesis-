#include <TinyGPS++.h>
#include <SoftwareSerial.h>
#include <Wire.h>
#include <MPU6050.h>

#define DEBUG

#ifdef DEBUG
#define DEBUG_PRINT(...) Serial.print(__VA_ARGS__)
#define DEBUG_PRINTLN(...) Serial.println(__VA_ARGS__)
#else
#define DEBUG_PRINT(...)
#define DEBUG_PRINTLN(...)
#endif

TinyGPSPlus gps;
MPU6050 mpu;
#define GPS_SERIAL Serial1
#define HC12_SERIAL Serial3

// Motor control pins
const int ENA = 12;    // Left motor PWM
const int ENB = 13;    // Right motor PWM
const int motorPin1 = 8;  // Left motor direction 1
const int motorPin2 = 9;  // Left motor direction 2
const int motorPin3 = 11; // Right motor direction 1
const int motorPin4 = 10; // Right motor direction 2

// MPU-6050 variables
float accAngle, gyroAngle, currentAngle;
unsigned long prevTime = 0;
float gyroError = 0;
bool mpuInitialized = false;

struct MotorCommand {
  int leftPWM;
  int rightPWM;
};
MotorCommand currentCommand = {0, 0};
unsigned long lastCommandTime = 0;
const unsigned long COMMAND_TIMEOUT = 2000; // 2 seconds

void setup() {
  #ifdef DEBUG
  Serial.begin(115200);
  #endif
  
  GPS_SERIAL.begin(9600);
  HC12_SERIAL.begin(9600);
  
  // Initialize motor control pins
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorPin3, OUTPUT);
  pinMode(motorPin4, OUTPUT);
  
  // Initialize MPU-6050
  Wire.begin();
  byte status = mpu.begin();
  if (status == 0) {
    DEBUG_PRINTLN("MPU6050 found!");
    mpuInitialized = true;
    
    // Calibrate gyroscope
    calibrateGyro();
    
    // Set accelerometer range (optional)
    mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
    
    // Set gyro range (optional)
    mpu.setGyroRange(MPU6050_RANGE_250_DEG);
    
    // Set filter bandwidth (optional)
    mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  } else {
    DEBUG_PRINTLN("MPU6050 not found!");
    mpuInitialized = false;
  }
  
  DEBUG_PRINTLN("Robot Initialized");
}

void loop() {
  // Read GPS data
  while (GPS_SERIAL.available() > 0) {
    if (gps.encode(GPS_SERIAL.read())) {
      if (gps.location.isValid() && gps.location.isUpdated()) {
        sendGPSData();
      }
    }
  }
  
  // Read and process MPU-6050 data if available
  if (mpuInitialized) {
    updateIMUData();
  }
  
  // Check for incoming commands
  if (HC12_SERIAL.available() > 0) {
    String command = HC12_SERIAL.readStringUntil('\n');
    if (command.startsWith("CMD:")) {
      parseMotorCommand(command);
      executeMotorCommand();
      lastCommandTime = millis();
    }
  }
  
  // Safety timeout - stop if no commands received
  if (millis() - lastCommandTime > COMMAND_TIMEOUT) {
    currentCommand = {0, 0};
    executeMotorCommand();
    DEBUG_PRINTLN("Command timeout - stopping");
  }
  
  delay(50);
}

void calibrateGyro() {
  DEBUG_PRINTLN("Calibrating MPU6050...");
  
  // Read 200 samples for calibration
  for (int i = 0; i < 200; i++) {
    Vector rawGyro = mpu.readRawGyro();
    gyroError += rawGyro.Z;
    delay(10);
  }
  
  gyroError /= 200;
  DEBUG_PRINT("Gyro error: ");
  DEBUG_PRINTLN(gyroError);
}

void updateIMUData() {
  // Read accelerometer and gyroscope data
  Vector rawAccel = mpu.readRawAccel();
  Vector rawGyro = mpu.readRawGyro();
  
  // Calculate time difference
  unsigned long currentTime = millis();
  float deltaTime = (currentTime - prevTime) / 1000.0;
  prevTime = currentTime;
  
  // Calculate tilt angle from accelerometer (pitch)
  accAngle = atan2(rawAccel.Y, rawAccel.X) * 180/PI + 90;
  
  // Calculate angular speed from gyro (Z-axis for heading)
  float gyroRate = (rawGyro.Z - gyroError) / 131.0; // Convert to deg/s
  
  // Complementary filter to combine accel and gyro data
  currentAngle = 0.98 * (currentAngle + gyroRate * deltaTime) + 0.02 * accAngle;
  
  #ifdef DEBUG
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 500) {
    DEBUG_PRINT("Acc Angle: ");
    DEBUG_PRINT(accAngle);
    DEBUG_PRINT(" | Gyro Rate: ");
    DEBUG_PRINT(gyroRate);
    DEBUG_PRINT(" | Current Angle: ");
    DEBUG_PRINTLN(currentAngle);
    lastPrint = millis();
  }
  #endif
}

void sendGPSData() {
  float latitude = gps.location.lat();
  float longitude = gps.location.lng();
  float speed = gps.speed.mps();
  float course = gps.course.deg();
  
  // If MPU is available, augment GPS heading with IMU data
  if (mpuInitialized) {
    // Simple fusion - use GPS course when speed is sufficient, otherwise use IMU
    if (speed > 0.5) { // 0.5 m/s threshold
      // Weighted average between GPS and IMU
      course = (course * 0.7) + (currentAngle * 0.3);
    } else {
      course = currentAngle;
    }
  }
  
  HC12_SERIAL.print("GPS:");
  HC12_SERIAL.print(latitude, 6);
  HC12_SERIAL.print(",");
  HC12_SERIAL.print(longitude, 6);
  HC12_SERIAL.print(",");
  HC12_SERIAL.print(speed, 2);
  HC12_SERIAL.print(",");
  HC12_SERIAL.println(course, 2);
  
  DEBUG_PRINT("GPS: ");
  DEBUG_PRINT(latitude, 6);
  DEBUG_PRINT(", ");
  DEBUG_PRINT(longitude, 6);
  DEBUG_PRINT(" | Heading: ");
  DEBUG_PRINTLN(course);
}

void parseMotorCommand(String command) {
  int commaIndex = command.indexOf(',', 4);
  if (commaIndex != -1) {
    currentCommand.leftPWM = command.substring(4, commaIndex).toInt();
    currentCommand.rightPWM = command.substring(commaIndex + 1).toInt();
  }
}

void executeMotorCommand() {
  // Left motor
  if (currentCommand.leftPWM > 0) {
    digitalWrite(motorPin1, LOW);
    digitalWrite(motorPin2, HIGH);
  } else if (currentCommand.leftPWM < 0) {
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, LOW);
  } else {
    digitalWrite(motorPin1, HIGH);
    digitalWrite(motorPin2, HIGH);
  }
  
  // Right motor
  if (currentCommand.rightPWM > 0) {
    digitalWrite(motorPin3, LOW);
    digitalWrite(motorPin4, HIGH);
  } else if (currentCommand.rightPWM < 0) {
    digitalWrite(motorPin3, HIGH);
    digitalWrite(motorPin4, LOW);
  } else {
    digitalWrite(motorPin3, HIGH);
    digitalWrite(motorPin4, LOW);
  }
  
  analogWrite(ENA, constrain(abs(currentCommand.leftPWM) * 2.55, 0, 255));
  analogWrite(ENB, constrain(abs(currentCommand.rightPWM) * 2.55, 0, 255));
  
  DEBUG_PRINT("Motors: L=");
  DEBUG_PRINT(currentCommand.leftPWM);
  DEBUG_PRINT(", R=");
  DEBUG_PRINTLN(currentCommand.rightPWM);
}

//MPU-6050 SDA	20	I2C Data
//MPU-6050 SCL	21	I2C Clock
